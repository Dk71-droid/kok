const SPREADSHEET_ID = '1OTo8qLrfZfK0u7GseyA9BK0kKeAJdcEYnp8heI-xT-8';
const CASH_FUND_MEMBER_ID = 'kas_klub'; // ID khusus untuk saldo kas klub
const APP_DATA_SHEET_NAME = 'AppData'; // Nama sheet untuk menyimpan data cache/formulasi

// Mapping sel untuk data cache di sheet AppData
const APP_DATA_CELLS = {
  DASHBOARD: 'A1',
  MEMBERS_AND_IURAN: 'A2', // Digunakan untuk tab Anggota dan data dropdown Iuran
  EXPENSES: 'A3',
  SETTINGS: 'A4' // Untuk tarif
};

// ===== HELPER FUNCTIONS FOR APP DATA CACHE HANDLING =====

/**
 * Reads and parses JSON data from a specific cell in the AppData sheet.
 * Uses LockService to prevent concurrent modifications.
 * @param {string} cellAddress The A1 notation of the cell (e.g., 'A1').
 * @returns {object|null} The parsed JSON object, or null if cell is empty/invalid.
 */
function readAppDataCache(cellAddress) {
  const lock = LockService.getScriptLock();
  lock.waitLock(30000); // Tunggu hingga 30 detik untuk mendapatkan kunci

  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName(APP_DATA_SHEET_NAME);
    if (!sheet) {
      Logger.log(`Sheet '${APP_DATA_SHEET_NAME}' tidak ditemukan saat membaca cache.`);
      return null;
    }

    const jsonString = sheet.getRange(cellAddress).getValue();
    if (!jsonString) {
      return null;
    }
    return JSON.parse(jsonString);
  } catch (e) {
    Logger.log(`Error reading AppData cache from ${cellAddress}: ${e.message}`);
    return null;
  } finally {
    lock.releaseLock();
  }
}

/**
 * Saves a JavaScript object as a JSON string to a specific cell in the AppData sheet.
 * Uses LockService to prevent concurrent modifications.
 * @param {string} cellAddress The A1 notation of the cell (e.g., 'A1').
 * @param {object} dataObject The object to save.
 */
function writeAppDataCache(cellAddress, dataObject) {
  const lock = LockService.getScriptLock();
  lock.waitLock(30000); // Tunggu hingga 30 detik untuk mendapatkan kunci

  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName(APP_DATA_SHEET_NAME);
    if (!sheet) {
      Logger.log(`Sheet '${APP_DATA_SHEET_NAME}' tidak ditemukan saat menulis cache.`);
      return;
    }
    sheet.getRange(cellAddress).setValue(JSON.stringify(dataObject));
  } catch (e) {
    Logger.log(`Error saving AppData cache to ${cellAddress}: ${e.message}`);
  } finally {
    lock.releaseLock();
  }
}

// ===== HANDLER GET =====
function doGet(e) {
  const action = e.parameter.action;
  let result;
  try {
    switch (action) {
      case 'getMembers': result = getMembers(); break;
      case 'getDashboardSummary': result = getDashboardSummary(); break;
      case 'getExpenses': result = getExpenses(); break;
      case 'getCurrentTariff': result = getCurrentTariff(); break;
      case 'getIuranTransactions': result = getIuranTransactions(); break;
      default:
        throw new Error('Aksi tidak dikenal: ' + action);
    }
    return ContentService.createTextOutput(JSON.stringify(result)).setMimeType(ContentService.MimeType.JSON);
  } catch (error) {
    Logger.log(`Error in doGet for action ${action}: ${error.message}`);
    return ContentService.createTextOutput(JSON.stringify({ error: error.message }))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

// ===== HANDLER POST =====
function doPost(e) {
  const action = e.parameter.action;
  const data = JSON.parse(e.parameter.data || '{}');
  let result;
  try {
    switch (action) {
      case 'addMember': result = addMember(data); break;
      case 'updateMember': result = updateMember(data); break;
      case 'deleteMember': result = deleteMember(data); break;
      case 'recordPayment': result = recordPayment(data); break;
      case 'depositBalance': result = depositBalance(data); break;
      case 'setTariff': result = setTariff(data); break;
      case 'recordExpense': result = recordExpense(data); break;
      case 'resetData': result = resetData(data); break; // Aksi baru untuk reset
      case 'recordBatchPayments': result = recordBatchPayments(data); break; // Aksi baru untuk pembayaran batch
      default:
        throw new Error('Aksi tidak dikenal (POST): ' + action);
    }
    return ContentService.createTextOutput(JSON.stringify(result)).setMimeType(ContentService.MimeType.JSON);
  } catch (error) {
    Logger.log(`Error in doPost for action ${action}: ${error.message}`);
    return ContentService.createTextOutput(JSON.stringify({ error: error.message }))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

// ===== GET MEMBERS (Membaca dari sheet 'Anggota', memperbarui cache AppData!A2) =====
function getMembers() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName('Anggota');
  if (!sheet) throw new Error("Sheet 'Anggota' tidak ditemukan.");

  const data = sheet.getDataRange().getValues();
  const members = [];

  for (let i = 1; i < data.length; i++) {
    members.push({
      id: data[i][0],
      name: data[i][1],
      balance: parseFloat(data[i][2]) || 0 // Pastikan saldo adalah angka
    });
  }

  const tariff = getTariffOnly(); // Mengambil tarif terkini dari sheet 'Tarif'
  const membersForCache = members.filter(m => m.id !== CASH_FUND_MEMBER_ID); // Memfilter Kas Klub untuk cache anggota
  
  const result = { members: membersForCache, currentTariff: tariff };
  writeAppDataCache(APP_DATA_CELLS.MEMBERS_AND_IURAN, result); // Memperbarui cache
  
  return result; // Mengembalikan objek langsung, doGet akan meng-JSON.stringify
}

// ===== GET DASHBOARD SUMMARY (Membaca dari sheet 'Anggota' & 'Iuran', memperbarui cache AppData!A1) =====
function getDashboardSummary() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const anggotaSheet = ss.getSheetByName('Anggota');
  if (!anggotaSheet) throw new Error("Sheet 'Anggota' tidak ditemukan.");

  const membersData = anggotaSheet.getDataRange().getValues();
  const members = [];
  for (let i = 1; i < membersData.length; i++) {
    const member = {
      id: membersData[i][0],
      name: membersData[i][1],
      balance: parseFloat(membersData[i][2]) || 0
    };
    members.push(member);
  }

  const unpaidDebts = []; // Ini akan berisi detail utang per anggota (berdasarkan saldo negatif)
  let totalUnpaidAmount = 0;
  let totalCashBalance = 0;

  // Mendapatkan saldo Kas Klub
  const kasKlubMember = members.find(m => m.id === CASH_FUND_MEMBER_ID);
  if (kasKlubMember) {
    totalCashBalance = kasKlubMember.balance;
  }

  // Menghitung utang belum dibayar dari saldo anggota
  members.forEach(member => {
    if (member.id !== CASH_FUND_MEMBER_ID && member.balance < 0) {
      unpaidDebts.push({
        memberId: member.id,
        name: member.name,
        amount: Math.abs(member.balance) // Utang adalah nilai absolut dari saldo negatif
      });
      totalUnpaidAmount += Math.abs(member.balance);
    }
  });

  const currentTariff = getTariffOnly();

  const dashboardSummary = {
    unpaidDebts: unpaidDebts,  // Data utang yang sudah diagregasi dari saldo anggota
    totalUnpaidAmount: totalUnpaidAmount,  // Total akumulasi utang (dari saldo negatif)
    totalCashBalance: totalCashBalance,   // Total saldo kas klub
    memberBalances: members, // Saldo semua anggota (untuk tabel)
    currentTariff: currentTariff
  };

  writeAppDataCache(APP_DATA_CELLS.DASHBOARD, dashboardSummary); // Memperbarui cache

  return dashboardSummary; // Mengembalikan objek langsung
}

/**
 * Fungsi internal untuk mencatat satu pembayaran ke sheet Iuran dan memperbarui saldo anggota.
 * Tidak melakukan cache update atau LockService, itu ditangani oleh pemanggil.
 * @param {object} payload - Payment details.
 * {string} memberId - ID anggota.
 * {number} jumlahMain - Jumlah main.
 * {string} statusBayar - "sudah_bayar" atau "belum_bayar".
 * {number} tariff - Tarif per main untuk pembayaran ini.
 * {string} date - Tanggal pembayaran (YYYY-MM-DD).
 * {string} paymentMethod - "cash" atau "balance" atau "none".
 */
function recordPaymentInternal(payload) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheetIuran = ss.getSheetByName('Iuran');
  const sheetAnggota = ss.getSheetByName('Anggota');

  if (!sheetIuran) throw new Error("Sheet 'Iuran' tidak ditemukan.");
  if (!sheetAnggota) throw new Error("Sheet 'Anggota' tidak ditemukan.");

  const anggotaData = sheetAnggota.getDataRange().getValues();
  const anggotaHeaders = anggotaData.length > 0 ? anggotaData[0] : [];
  const ID_ANGGOTA_COL_ANGGOTA = anggotaHeaders.indexOf('ID');
  const SALDO_COL_ANGGOTA = anggotaHeaders.indexOf('Saldo');
  const NAMA_COL_ANGGOTA = anggotaHeaders.indexOf('Nama');

  if (ID_ANGGOTA_COL_ANGGOTA === -1 || SALDO_COL_ANGGOTA === -1 || NAMA_COL_ANGGOTA === -1) {
    throw new Error("Kolom 'ID', 'Nama', atau 'Saldo' tidak ditemukan di sheet 'Anggota'.");
  }

  let memberRowIndex = -1;
  let memberName = '';
  for (let i = 1; i < anggotaData.length; i++) {
    if (anggotaData[i][ID_ANGGOTA_COL_ANGGOTA] === payload.memberId) {
      memberRowIndex = i + 1; // Baris berbasis 1
      memberName = anggotaData[i][NAMA_COL_ANGGOTA];
      break;
    }
  }

  if (memberRowIndex === -1) {
    throw new Error(`Anggota dengan ID ${payload.memberId} tidak ditemukan.`);
  }

  const nominalIuran = payload.jumlahMain * payload.tariff;
  const currentMemberBalance = parseFloat(sheetAnggota.getRange(memberRowIndex, SALDO_COL_ANGGOTA + 1).getValue()) || 0;
  const timestamp = new Date();

  let newMemberBalance = currentMemberBalance;
  let kasKlubChange = 0; // Amount to add to kas_klub

  if (payload.statusBayar === "belum_bayar") {
    // Jika 'Belum Bayar', saldo anggota berkurang (utang bertambah)
    newMemberBalance = currentMemberBalance - nominalIuran;
  } else if (payload.statusBayar === "sudah_bayar") {
    if (payload.paymentMethod === "balance") {
      // Jika 'Sudah Bayar' dan pembayaran dari 'balance', saldo anggota berkurang
      newMemberBalance = currentMemberBalance - nominalIuran;
      // Saldo Kas Klub TIDAK BERUBAH karena uang bergerak secara internal dari saldo anggota
    } else if (payload.paymentMethod === "cash") {
      // Jika 'Sudah Bayar' dan pembayaran adalah 'cash', saldo anggota tidak berubah,
      // tetapi dana kas klub bertambah.
      newMemberBalance = currentMemberBalance;
      kasKlubChange = nominalIuran; // Tambahkan ke kas_klub
    }
  }

  // Perbarui saldo anggota
  sheetAnggota.getRange(memberRowIndex, SALDO_COL_ANGGOTA + 1).setValue(newMemberBalance);

  // Perbarui saldo Kas Klub jika ada perubahan (hanya untuk pembayaran tunai)
  if (kasKlubChange !== 0) {
    const kasKlubRowIndex = anggotaData.findIndex(row => row[ID_ANGGOTA_COL_ANGGOTA] === CASH_FUND_MEMBER_ID) + 1;
    if (kasKlubRowIndex > 0) {
      const currentKasKlubBalance = parseFloat(sheetAnggota.getRange(kasKlubRowIndex, SALDO_COL_ANGGOTA + 1).getValue()) || 0;
      sheetAnggota.getRange(kasKlubRowIndex, SALDO_COL_ANGGOTA + 1).setValue(currentKasKlubBalance + kasKlubChange);
    } else {
      Logger.log(`Warning: Anggota dengan ID ${CASH_FUND_MEMBER_ID} tidak ditemukan. Dana kas tidak diperbarui untuk pembayaran 'sudah_bayar' dengan metode 'cash'.`);
    }
  }

  // Memperbarui sheet Iuran
  const iuranHeaders = sheetIuran.getDataRange().getValues()[0];
  const TIPE_TRANSAKSI_COL_INDEX = iuranHeaders.indexOf('Tipe_Transaksi');
  if (TIPE_TRANSAKSI_COL_INDEX === -1) {
      throw new Error("Kolom 'Tipe_Transaksi' tidak ditemukan di sheet 'Iuran'. Harap jalankan setupSpreadsheet.");
  }

  const newRow = [];
  const expectedHeaders = ['Tanggal', 'Nama_Anggota', 'Jumlah_Main', 'Nominal', 'Tipe_Transaksi', 'Status_Iuran', 'Metode_Pembayaran', 'Timestamp'];

  expectedHeaders.forEach(header => {
      switch(header) {
          case 'Tanggal': newRow.push(payload.date); break;
          case 'Nama_Anggota': newRow.push(memberName); break;
          case 'Jumlah_Main': newRow.push(payload.jumlahMain); break;
          case 'Nominal': newRow.push(nominalIuran); break;
          case 'Tipe_Transaksi': newRow.push("Iuran"); break;
          case 'Status_Iuran': newRow.push(payload.statusBayar === "sudah_bayar" ? "Lunas" : "Belum Lunas"); break;
          case 'Metode_Pembayaran': newRow.push(payload.paymentMethod); break;
          case 'Timestamp': newRow.push(timestamp); break;
          default: newRow.push('');
      }
  });

  sheetIuran.appendRow(newRow);
}


// ===== RECORD PAYMENT (Wrapper publik untuk satu pembayaran) =====
function recordPayment(payload) {
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);
  try {
    recordPaymentInternal(payload); // Panggil fungsi internal
    getMembers(); // Refresh members data first
    const updatedDashboardSummary = getDashboardSummary(); // Then refresh dashboard summary
    return { success: true, message: "Iuran berhasil dicatat.", updatedDashboard: updatedDashboardSummary };
  } finally {
    lock.releaseLock();
  }
}

/**
 * Mencatat beberapa pembayaran iuran secara bersamaan (batch).
 * @param {object} data - Objek yang berisi array pembayaran.
 * @param {Array<object>} data.payments - Array objek pembayaran, setiap objek berisi:
 * {string} memberId - ID anggota.
 * {number} jumlahMain - Jumlah main.
 * {string} statusBayar - "sudah_bayar" atau "belum_bayar".
 * {number} tariff - Tarif per main untuk pembayaran ini.
 * {string} date - Tanggal pembayaran (YYYY-MM-DD).
 * {string} memberName - Nama anggota (untuk logging/pesan).
 */
function recordBatchPayments(data) {
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  let successCount = 0;
  let errorMessages = [];

  try {
    if (!data.payments || !Array.isArray(data.payments)) {
      throw new Error("Payload pembayaran batch tidak valid.");
    }

    data.payments.forEach(payment => {
      try {
        // Untuk pembayaran batch, paymentMethod selalu dianggap 'cash'
        // jika statusBayar adalah 'sudah_bayar' karena tidak ada mekanisme
        // pengecekan saldo perorangan di sini. Saldo perorangan hanya berubah
        // jika statusBayar 'belum_bayar' (menjadi utang).
        
        recordPaymentInternal({
          memberId: payment.memberId,
          jumlahMain: payment.jumlahMain,
          statusBayar: payment.statusBayar,
          tariff: payment.tariff,
          date: payment.date,
          paymentMethod: payment.statusBayar === "sudah_bayar" ? "cash" : "none" // Disini paymentMethod disesuaikan
        });
        successCount++;
      } catch (e) {
        errorMessages.push(`Gagal memproses pembayaran untuk ${payment.memberName || payment.memberId}: ${e.message}`);
        Logger.log(`Error processing batch payment for ${payment.memberName || payment.memberId}: ${e.message}`);
      }
    });

    // Setelah semua pembayaran diproses, refresh AppData cache sekali
    getMembers();
    getDashboardSummary();
    getExpenses();
    getCurrentTariff();

    return { 
      success: true, 
      message: `${successCount} pembayaran berhasil dicatat.`,
      errors: errorMessages
    };

  } catch (outerError) {
    Logger.log(`Error in recordBatchPayments: ${outerError.message}`);
    return { success: false, message: `Gagal memproses pembayaran batch: ${outerError.message}`, errors: errorMessages };
  } finally {
    lock.releaseLock();
  }
}

/**
 * Mengambil semua transaksi iuran dari sheet 'Iuran'.
 * Data ini tidak di-cache secara otomatis, hanya diambil saat diminta.
 * @returns {object} Objek berisi array transaksi iuran.
 */
function getIuranTransactions() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName('Iuran');
  if (!sheet) throw new Error("Sheet 'Iuran' tidak ditemukan.");

  const data = sheet.getDataRange().getValues();
  const transactions = [];

  // Get headers to find column indices dynamically
  const headers = data.length > 0 ? data[0] : [];
  const TANGGAL_COL = headers.indexOf('Tanggal');
  const NAMA_ANGGOTA_COL = headers.indexOf('Nama_Anggota');
  const JUMLAH_MAIN_COL = headers.indexOf('Jumlah_Main');
  const NOMINAL_COL = headers.indexOf('Nominal');
  const TIPE_TRANSAKSI_COL = headers.indexOf('Tipe_Transaksi'); // NEW
  const STATUS_IURAN_COL = headers.indexOf('Status_Iuran');
  const METODE_PEMBAYARAN_COL = headers.indexOf('Metode_Pembayaran');
  const TIMESTAMP_COL = headers.indexOf('Timestamp');

  if (data.length > 1) {
    for (let i = 1; i < data.length; i++) {
      transactions.push({
        date: data[i][TANGGAL_COL],
        memberName: data[i][NAMA_ANGGOTA_COL],
        jumlahMain: parseFloat(data[i][JUMLAH_MAIN_COL]) || 0,
        nominal: parseFloat(data[i][NOMINAL_COL]) || 0,
        type: data[i][TIPE_TRANSAKSI_COL] || 'Iuran', // Default to 'Iuran' if not specified
        statusIuran: data[i][STATUS_IURAN_COL],
        metodePembayaran: data[i][METODE_PEMBAYARAN_COL],
        timestamp: data[i][TIMESTAMP_COL] // Opsional, bisa digunakan untuk sorting
      });
    }
  }
  // Mengurutkan transaksi dari yang terbaru ke terlama berdasarkan timestamp
  transactions.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

  return { transactions: transactions };
}


// ===== GET EXPENSES (Membaca dari sheet 'Pengeluaran', memperbarui cache AppData!A3) =====
function getExpenses() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName('Pengeluaran');
  if (!sheet) throw new Error("Sheet 'Pengeluaran' tidak ditemukan.");

  const data = sheet.getDataRange().getValues();
  const expenses = data.slice(1).map(r => ({ description: r[0], amount: parseFloat(r[1]) || 0, date: r[2] }));

  const result = { expenses };
  writeAppDataCache(APP_DATA_CELLS.EXPENSES, result); // Memperbarui cache

  return result; // Mengembalikan objek langsung
}

// ===== RECORD EXPENSE (Memperbarui sheet Pengeluaran & Anggota) =====
function recordExpense(data) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const expenseSheet = ss.getSheetByName('Pengeluaran');
  const memberSheet = ss.getSheetByName('Anggota');

  if (!expenseSheet) throw new Error("Sheet 'Pengeluaran' tidak ditemukan.");
  if (!memberSheet) throw new Error("Sheet 'Anggota' tidak ditemukan.");

  // 1. Menambahkan pengeluaran ke sheet 'Pengeluaran'
  expenseSheet.appendRow([data.description, data.amount, data.date]);

  // 2. Mengurangi jumlah pengeluaran dari saldo anggota 'Kas Klub'
  const memberData = memberSheet.getDataRange().getValues();
  const memberHeaders = memberData.length > 0 ? memberData[0] : [];
  const ID_COL_MEMBER = memberHeaders.indexOf('ID');
  const SALDO_COL_MEMBER = memberHeaders.indexOf('Saldo');

  let kasKlubRowIndex = -1;

  // Mencari baris anggota 'Kas Klub'
  for (let i = 1; i < memberData.length; i++) {
    if (memberData[i][ID_COL_MEMBER] === CASH_FUND_MEMBER_ID) {
      kasKlubRowIndex = i + 1; // +1 karena baris sheet berbasis 1
      break;
    }
  }

  if (kasKlubRowIndex !== -1) {
    const currentKasKlubBalance = parseFloat(memberSheet.getRange(kasKlubRowIndex, SALDO_COL_MEMBER + 1).getValue()) || 0;
    const newKasKlubBalance = currentKasKlubBalance - parseFloat(data.amount);
    memberSheet.getRange(kasKlubRowIndex, SALDO_COL_MEMBER + 1).setValue(newKasKlubBalance);
  } else {
    Logger.log(`Warning: Anggota dengan ID ${CASH_FUND_MEMBER_ID} tidak ditemukan. Pengeluaran tidak dikurangi dari saldo kas.`);
  }

  return { success: true, message: 'Pengeluaran dicatat dan saldo kas diperbarui.' };
}


// ===== DEPOSIT (Memperbarui sheet Anggota dan mencatat di Iuran) =====
/**
 * Mencatat setoran saldo oleh anggota.
 * Setoran ini diasumsikan sebagai uang tunai baru yang masuk ke sistem.
 * Saldo anggota yang menyetor akan bertambah, dan saldo Kas Klub juga akan bertambah.
 * @param {object} data Objek yang berisi memberId dan amount.
 */
function depositBalance(data) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheetAnggota = ss.getSheetByName('Anggota');
  const sheetIuran = ss.getSheetByName('Iuran'); 

  if (!sheetAnggota) throw new Error("Sheet 'Anggota' tidak ditemukan.");
  if (!sheetIuran) throw new Error("Sheet 'Iuran' tidak ditemukan.");

  const anggotaData = sheetAnggota.getDataRange().getValues();
  const anggotaHeaders = anggotaData.length > 0 ? anggotaData[0] : [];
  const ID_ANGGOTA_COL_ANGGOTA = anggotaHeaders.indexOf('ID');
  const SALDO_COL_ANGGOTA = anggotaHeaders.indexOf('Saldo');
  const NAMA_COL_ANGGOTA = anggotaHeaders.indexOf('Nama');

  let memberRowIndex = -1;
  let memberName = '';
  for (let i = 1; i < anggotaData.length; i++) {
    if (anggotaData[i][ID_ANGGOTA_COL_ANGGOTA] === data.memberId) {
      memberRowIndex = i + 1;
      memberName = anggotaData[i][NAMA_COL_ANGGOTA];
      break;
    }
  }

  if (memberRowIndex === -1) {
    throw new Error("Anggota tidak ditemukan.");
  }

  const currentMemberBalance = parseFloat(sheetAnggota.getRange(memberRowIndex, SALDO_COL_ANGGOTA + 1).getValue()) || 0;
  let depositAmount = parseFloat(data.amount); // Use let because it will be reduced
  const originalDepositAmount = depositAmount; // Store original for transactionType logic
  const newMemberBalance = currentMemberBalance + depositAmount;

  // Memperbarui saldo anggota
  sheetAnggota.getRange(memberRowIndex, SALDO_COL_ANGGOTA + 1).setValue(newMemberBalance);

  // Memperbarui saldo Kas Klub jika anggota biasa melakukan setoran
  if (data.memberId !== CASH_FUND_MEMBER_ID) {
    const kasKlubRowIndex = anggotaData.findIndex(row => row[ID_ANGGOTA_COL_ANGGOTA] === CASH_FUND_MEMBER_ID) + 1;
    if (kasKlubRowIndex > 0) {
      const currentKasKlubBalance = parseFloat(sheetAnggota.getRange(kasKlubRowIndex, SALDO_COL_ANGGOTA + 1).getValue()) || 0;
      sheetAnggota.getRange(kasKlubRowIndex, SALDO_COL_ANGGOTA + 1).setValue(currentKasKlubBalance + originalDepositAmount); // Use originalDepositAmount here
    } else {
      Logger.log(`Warning: Anggota dengan ID ${CASH_FUND_MEMBER_ID} tidak ditemukan. Saldo kas klub tidak diperbarui untuk setoran anggota.`);
    }
  }

  // --- LOGIKA BARU: Menentukan Tipe_Transaksi untuk setoran ---
  let transactionType = "";
  const initialMemberBalance = currentMemberBalance; // Saldo anggota sebelum setoran

  if (initialMemberBalance < 0) { // Anggota punya utang
      const outstandingDebt = Math.abs(initialMemberBalance);

      if (originalDepositAmount === outstandingDebt) {
          transactionType = "Pelunasan Utang";
      } else if (originalDepositAmount < outstandingDebt) {
          transactionType = "Bayar Utang";
      } else { // originalDepositAmount > outstandingDebt
          transactionType = "Pelunasan dan Tambah Saldo";
      }
  } else { // Anggota tidak punya utang atau saldo positif
      transactionType = "Setoran Saldo";
  }

  // Logika untuk memperbarui status Iuran berdasarkan saldo baru (hanya untuk anggota biasa)
  // Ini adalah logika untuk menandai Iuran yang 'Belum Lunas' menjadi 'Lunas' setelah setoran.
  if (data.memberId !== CASH_FUND_MEMBER_ID) {
    const iuranAllData = sheetIuran.getDataRange().getValues();
    const iuranAllHeaders = iuranAllData.length > 0 ? iuranAllData[0] : [];
    const NAMA_ANGGOTA_COL_IURAN = iuranAllHeaders.indexOf('Nama_Anggota');
    const STATUS_BAYAR_COL_IURAN = iuranAllHeaders.indexOf('Status_Iuran');
    const NOMINAL_COL_IURAN_SHEET = iuranAllHeaders.indexOf('Nominal');
    const TIPE_TRANSAKSI_COL_IURAN = iuranAllHeaders.indexOf('Tipe_Transaksi');

    // Memfilter entri 'Iuran' yang 'Belum Lunas' untuk anggota ini, diurutkan berdasarkan timestamp (terlama dulu)
    const unpaidIuranRows = [];
    for(let i = 1; i < iuranAllData.length; i++) {
      const rowType = iuranAllData[i][TIPE_TRANSAKSI_COL_IURAN] || 'Iuran'; 
      const rowMemberName = iuranAllData[i][NAMA_ANGGOTA_COL_IURAN];
      
      if (rowType === 'Iuran' && rowMemberName === memberName && iuranAllData[i][STATUS_BAYAR_COL_IURAN] === 'Belum Lunas') {
        unpaidIuranRows.push({
          rowIndex: i + 1, // Indeks baris berbasis 1 di sheet
          data: iuranAllData[i],
          timestamp: new Date(iuranAllData[i][iuranAllHeaders.indexOf('Timestamp')]) // Use timestamp for accurate sorting
        });
      }
    }
    // Mengurutkan berdasarkan timestamp
    unpaidIuranRows.sort((a, b) => a.timestamp - b.timestamp);

    // Apply the original deposit amount to outstanding debts
    let remainingDepositToApply = originalDepositAmount;

    for (const entry of unpaidIuranRows) {
      if (remainingDepositToApply <= 0) break; // If deposit is exhausted, stop applying

      const nominalIuranEntry = (parseFloat(entry.data[NOMINAL_COL_IURAN_SHEET]) || 0);
      
      if (remainingDepositToApply >= nominalIuranEntry) {
        sheetIuran.getRange(entry.rowIndex, STATUS_BAYAR_COL_IURAN + 1).setValue('Lunas');
        remainingDepositToApply -= nominalIuranEntry;
      } else {
        // If deposit is not enough to cover the current debt, it's partially paid
        // We don't change the status to 'Lunas' yet, but we consume the deposit.
        remainingDepositToApply = 0; // Deposit is fully consumed
      }
    }
  }

  // Pastikan kolom 'Tipe_Transaksi' ada
  const iuranHeaders = sheetIuran.getDataRange().getValues()[0];
  const TIPE_TRANSAKSI_COL_INDEX = iuranHeaders.indexOf('Tipe_Transaksi');
  if (TIPE_TRANSAKSI_COL_INDEX === -1) {
      throw new Error("Kolom 'Tipe_Transaksi' tidak ditemukan di sheet 'Iuran'. Harap jalankan setupSpreadsheet.");
  }

  // Buat array baris baru sesuai urutan header
  const newRowForIuran = [];
  const expectedIuranHeaders = ['Tanggal', 'Nama_Anggota', 'Jumlah_Main', 'Nominal', 'Tipe_Transaksi', 'Status_Iuran', 'Metode_Pembayaran', 'Timestamp'];
  
  expectedIuranHeaders.forEach(header => {
      switch(header) {
          case 'Tanggal': newRowForIuran.push(new Date().toISOString().split('T')[0]); break;
          case 'Nama_Anggota': newRowForIuran.push(memberName); break;
          case 'Jumlah_Main': newRowForIuran.push(0); break; // Setoran tidak memiliki jumlah main
          case 'Nominal': newRowForIuran.push(originalDepositAmount); break; // Use original deposit amount here
          case 'Tipe_Transaksi': newRowForIuran.push(transactionType); break;
          case 'Status_Iuran': newRowForIuran.push("Lunas"); break; // Setoran selalu lunas
          case 'Metode_Pembayaran': newRowForIuran.push("cash"); break; // Asumsi setoran adalah cash/transfer
          case 'Timestamp': newRowForIuran.push(new Date()); break;
          default: newRowForIuran.push(''); // Kolom tidak dikenal
      }
  });
  sheetIuran.appendRow(newRowForIuran);

  return { success: true, message: "Saldo ditambah dan utang diperbarui." };
}

// ===== MEMBER MANAGEMENT (Memperbarui sheet Anggota) =====
function addMember(data) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName('Anggota');
  if (!sheet) throw new Error("Sheet 'Anggota' tidak ditemukan.");

  const newId = Utilities.getUuid();
  sheet.appendRow([newId, data.name, 0]);

  return { success: true, message: "Anggota ditambahkan.", id: newId };
}

function updateMember(data) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName('Anggota');
  if (!sheet) throw new Error("Sheet 'Anggota' tidak ditemukan.");

  const rows = sheet.getDataRange().getValues(); // Mendapatkan semua data termasuk header

  // Mencari baris header untuk mendapatkan indeks kolom
  const headers = rows[0];
  const ID_COL = headers.indexOf('ID');
  const NAMA_COL = headers.indexOf('Nama');

  if (ID_COL === -1 || NAMA_COL === -1) {
    throw new Error("Kolom 'ID' atau 'Nama' tidak ditemukan di sheet 'Anggota'.");
  }

  for (let i = 1; i < rows.length; i++) { // Mulai dari 1 untuk melewati header
    if (rows[i][ID_COL] === data.id) {
      sheet.getRange(i + 1, NAMA_COL + 1).setValue(data.name); // +1 untuk indeks berbasis 1
      return { success: true, message: "Anggota diperbarui." };
    }
  }
  throw new Error("Anggota tidak ditemukan.");
}

function deleteMember(data) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheetAnggota = ss.getSheetByName('Anggota');
  const sheetIuran = ss.getSheetByName('Iuran');

  if (!sheetAnggota) throw new Error("Sheet 'Anggota' tidak ditemukan.");
  if (!sheetIuran) throw new Error("Sheet 'Iuran' tidak ditemukan.");

  const anggotaRows = sheetAnggota.getDataRange().getValues();
  const anggotaHeaders = anggotaRows.length > 0 ? anggotaRows[0] : [];
  const ID_COL_ANGGOTA = anggotaHeaders.indexOf('ID');
  let memberRowToDelete = -1;
  for (let i = 1; i < anggotaRows.length; i++) {
    if (anggotaRows[i][ID_COL_ANGGOTA] === data.id) {
      memberRowToDelete = i + 1;
      break;
    }
  }

  if (memberRowToDelete !== -1) {
    sheetAnggota.deleteRow(memberRowToDelete);

    // Juga menghapus entri iuran terkait
    const iuranData = sheetIuran.getDataRange().getValues();
    const iuranHeaders = iuranData.length > 0 ? iuranData[0] : [];
    const ID_ANGGOTA_COL_IURAN = iuranHeaders.indexOf('ID_Anggota'); // Ini harusnya Nama_Anggota
    const NAMA_ANGGOTA_COL_IURAN = iuranHeaders.indexOf('Nama_Anggota'); // Gunakan Nama_Anggota untuk filtering
    const memberNameToDelete = anggotaRows[memberRowToDelete - 1][anggotaHeaders.indexOf('Nama')]; // Get name before deleting row

    const rowsToDeleteInIuran = [];
    for (let i = 1; i < iuranData.length; i++) {
      if (iuranData[i][NAMA_ANGGOTA_COL_IURAN] === memberNameToDelete) { // Filter by Name_Anggota
        rowsToDeleteInIuran.push(i + 1);
      }
    }
    // Menghapus baris dari bawah ke atas untuk menghindari masalah pergeseran indeks
    for (let i = rowsToDeleteInIuran.length - 1; i >= 0; i--) {
      sheetIuran.deleteRow(rowsToDeleteInIuran[i]);
    }

    return { success: true, message: "Anggota dan semua iurannya berhasil dihapus." };
  }
  throw new Error("Anggota tidak ditemukan.");
}

// ===== TARIFF (Memperbarui sheet Tarif) =====
function setTariff(data) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheetTarif = ss.getSheetByName('Tarif');
  if (!sheetTarif) throw new Error("Sheet 'Tarif' tidak ditemukan.");

  // Hapus semua baris kecuali header jika ada data lama
  if (sheetTarif.getLastRow() > 1) {
    sheetTarif.deleteRows(2, sheetTarif.getLastRow() - 1);
  }
  
  sheetTarif.appendRow([parseFloat(data.tariff) || 0, data.date]);

  return { success: true, message: "Tarif disimpan." };
}

function getTariffOnly() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName('Tarif');
  if (!sheet) {
    Logger.log("Sheet 'Tarif' tidak ditemukan. Mengembalikan tarif 0.");
    return 0; // Mengembalikan 0 jika sheet tidak ditemukan
  }
  
  const lastRow = sheet.getLastRow();
  
  // Pastikan ada setidaknya satu baris data selain header
  if (lastRow <= 1) {
    Logger.log("[getTariffOnly] Sheet 'Tarif' kosong atau hanya berisi header. Mengembalikan 0.");
    return 0;
  }

  const tariffHeaders = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const TARIF_MAIN_COL = tariffHeaders.indexOf('Tarif_Main');

  if (TARIF_MAIN_COL === -1) {
    Logger.log("[getTariffOnly] Kolom 'Tarif_Main' tidak ditemukan di sheet 'Tarif'. Mengembalikan 0.");
    return 0;
  }

  const tariffValue = sheet.getRange(lastRow, TARIF_MAIN_COL + 1).getValue();
  const parsedTariff = parseFloat(tariffValue);
  
  if (isNaN(parsedTariff)) {
    Logger.log(`[getTariffOnly] Peringatan: Nilai tarif tidak dapat diurai sebagai angka (${tariffValue}). Mengembalikan 0.`);
    return 0;
  }
  return parsedTariff;
}

function getCurrentTariff() {
  const tariff = getTariffOnly();
  const result = { tariff };
  writeAppDataCache(APP_DATA_CELLS.SETTINGS, result); // Memperbarui cache
  return result; // Mengembalikan objek langsung
}

// Helper untuk membersihkan sheet dan menyiapkan data awal (digunakan oleh setupSpreadsheet dan resetData)
function _clearAndSetupSheetsInternal() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);

  const sheetsToCreate = [
    { name: 'Anggota', headers: ['ID', 'Nama', 'Saldo'] },
    { name: 'Iuran', headers: ['Tanggal', 'Nama_Anggota', 'Jumlah_Main', 'Nominal', 'Tipe_Transaksi', 'Status_Iuran', 'Metode_Pembayaran', 'Timestamp'] }, // ADDED Tipe_Transaksi
    { name: 'Pengeluaran', headers: ['Keterangan', 'Nominal', 'Tanggal'] },
    { name: 'Tarif', headers: ['Tarif_Main', 'Tanggal'] }
  ];

  sheetsToCreate.forEach(sheetInfo => {
    let sheet = ss.getSheetByName(sheetInfo.name);
    if (!sheet) {
      sheet = ss.insertSheet(sheetInfo.name);
    }
    sheet.clearContents(); // Membersihkan semua data termasuk header
    sheet.getRange(1, 1, 1, sheetInfo.headers.length).setValues([sheetInfo.headers]);
    sheet.getRange(1, 1, 1, sheetInfo.headers.length).setFontWeight('bold');

    // Tambahkan nilai default untuk sheet 'Tarif' jika baru dibuat/direset
    if (sheetInfo.name === 'Tarif') {
      if (sheet.getLastRow() === 1) { // Hanya header yang ada
        sheet.appendRow([0, new Date().toISOString().split('T')[0]]); // Tambahkan tarif 0 dengan tanggal hari ini
        Logger.log("Tarif default 0 ditambahkan ke sheet 'Tarif'.");
      }
    }
  });

  const anggotaSheet = ss.getSheetByName('Anggota');
  const anggotaData = anggotaSheet.getDataRange().getValues();
  const anggotaHeaders = anggotaData.length > 0 ? anggotaData[0] : [];
  const ID_COL_ANGGOTA_SETUP = anggotaHeaders.indexOf('ID');
  
  let kasKlubExists = false;
  for (let i = 1; i < anggotaData.length; i++) {
    if (anggotaData[i][ID_COL_ANGGOTA_SETUP] === CASH_FUND_MEMBER_ID) {
      kasKlubExists = true;
      break;
    }
  }

  if (!kasKlubExists) {
    anggotaSheet.appendRow([CASH_FUND_MEMBER_ID, 'Kas Klub', 0]);
  } else {
    // Jika Kas Klub ada, pastikan saldonya 0 jika kita melakukan reset penuh
    const kasKlubRowIndex = anggotaData.findIndex(row => row[ID_COL_ANGGOTA_SETUP] === CASH_FUND_MEMBER_ID) + 1;
    if (kasKlubRowIndex > 0) {
      anggotaSheet.getRange(kasKlubRowIndex, anggotaHeaders.indexOf('Saldo') + 1).setValue(0);
    }
  }

  // Membersihkan sheet AppData
  let appDataSheet = ss.getSheetByName(APP_DATA_SHEET_NAME);
  if (!appDataSheet) {
    appDataSheet = ss.insertSheet(APP_DATA_SHEET_NAME);
  }
  appDataSheet.clearContents();
  writeAppDataCache(APP_DATA_CELLS.DASHBOARD, {});
  writeAppDataCache(APP_DATA_CELLS.MEMBERS_AND_IURAN, { members: [], currentTariff: 0 });
  writeAppDataCache(APP_DATA_CELLS.EXPENSES, { expenses: [] });
  writeAppDataCache(APP_DATA_CELLS.SETTINGS, { tariff: 0 });
}

// ===== SETUP SPREADSHEET (Jalankan fungsi ini sekali untuk menginisialisasi sheet) =====
function setupSpreadsheet() {
  try {
    _clearAndSetupSheetsInternal(); // Menggunakan helper internal
    Logger.log('Penyiapan Spreadsheet selesai.');
    // Setelah menyiapkan semua sheet, memicu pengisian cache awal
    getDashboardSummary();
    getMembers();
    getExpenses();
    getCurrentTariff();
    Logger.log('Cache AppData berhasil diisi setelah penyiapan.');
    SpreadsheetApp.getUi().alert('Penyiapan Spreadsheet Selesai', 'Semua sheet utama dan sheet AppData untuk caching berhasil dibuat/diperbarui. Data cache telah diinisialisasi.', SpreadsheetApp.getUi().ButtonSet.OK);
  } catch (error) {
    Logger.log('Error selama penyiapan spreadsheet: ' + error.message);
    SpreadsheetApp.getUi().alert('Error', 'Gagal mengatur spreadsheet: ' + error.message, SpreadsheetApp.getUi().ButtonSet.OK);
  }
}

/**
 * Mereset data aplikasi berdasarkan tipe reset.
 * @param {object} data Objek yang berisi resetType, startDate, dan endDate.
 */
function resetData(data) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const resetType = data.resetType;
  let message = "Data berhasil direset.";

  try {
    if (resetType === 'all') {
      _clearAndSetupSheetsInternal(); // Membersihkan semuanya dan menginisialisasi ulang
      message = "Semua data berhasil direset.";
    } else if (resetType === 'monthAgo' || resetType === 'dateRange') {
      const iuranSheet = ss.getSheetByName('Iuran');
      const pengeluaranSheet = ss.getSheetByName('Pengeluaran');
      const anggotaSheet = ss.getSheetByName('Anggota'); // Perlu untuk reset saldo anggota

      if (!iuranSheet) throw new Error("Sheet 'Iuran' tidak ditemukan.");
      if (!pengeluaranSheet) throw new Error("Sheet 'Pengeluaran' tidak ditemukan.");
      if (!anggotaSheet) throw new Error("Sheet 'Anggota' tidak ditemukan.");

      let startDate = null;
      let endDate = new Date(); // Tanggal akhir default hari ini

      if (resetType === 'monthAgo') {
        startDate = new Date();
        startDate.setMonth(startDate.getMonth() - 1);
        startDate.setDate(1); // Reset dari tanggal 1 bulan lalu
      } else if (resetType === 'dateRange') {
        if (!data.startDate || !data.endDate) {
          throw new Error("Rentang tanggal tidak valid.");
        }
        startDate = new Date(data.startDate);
        endDate = new Date(data.endDate);
      }
      endDate.setHours(23, 59, 59, 999); // Memastikan tanggal akhir mencakup sepanjang hari

      // Membersihkan baris di sheet Iuran dalam rentang
      const iuranData = iuranSheet.getDataRange().getValues();
      const iuranHeaders = iuranData.length > 0 ? iuranData[0] : [];
      const TANGGAL_COL_IURAN = iuranHeaders.indexOf('Tanggal');
      const rowsToDeleteIuran = [];

      for (let i = iuranData.length - 1; i >= 1; i--) { // Iterasi mundur, lewati header
        const rowDate = new Date(iuranData[i][TANGGAL_COL_IURAN]);
        if (rowDate >= startDate && rowDate <= endDate) {
          rowsToDeleteIuran.push(i + 1); // Menyimpan indeks baris berbasis 1
        }
      }
      rowsToDeleteIuran.forEach(rowIndex => iuranSheet.deleteRow(rowIndex));

      // Membersihkan baris di sheet Pengeluaran dalam rentang
      const pengeluaranData = pengeluaranSheet.getDataRange().getValues();
      const pengeluaranHeaders = pengeluaranData.length > 0 ? pengeluaranData[0] : [];
      const TANGGAL_COL_PENGELUARAN = pengeluaranHeaders.indexOf('Tanggal');
      const rowsToDeletePengeluaran = [];

      for (let i = pengeluaranData.length - 1; i >= 1; i--) { // Iterasi mundur, lewati header
        const rowDate = new Date(pengeluaranData[i][TANGGAL_COL_PENGELUARAN]);
        if (rowDate >= startDate && rowDate <= endDate) {
          rowsToDeletePengeluaran.push(i + 1); // Menyimpan indeks baris berbasis 1
        }
      }
      rowsToDeletePengeluaran.forEach(rowIndex => pengeluaranSheet.deleteRow(rowIndex));

      // Setelah menghapus transaksi, reset semua saldo anggota (kecuali Kas Klub) menjadi 0
      // Ini adalah pendekatan yang lebih aman untuk konsistensi data setelah reset sebagian transaksi.
      const anggotaData = anggotaSheet.getDataRange().getValues();
      const anggotaHeaders = anggotaData.length > 0 ? anggotaData[0] : [];
      const ID_COL_ANGGOTA = anggotaHeaders.indexOf('ID');
      const SALDO_COL_ANGGOTA = anggotaHeaders.indexOf('Saldo');

      for (let i = 1; i < anggotaData.length; i++) {
        const memberId = anggotaData[i][ID_COL_ANGGOTA];
        if (memberId !== CASH_FUND_MEMBER_ID) {
          anggotaSheet.getRange(i + 1, SALDO_COL_ANGGOTA + 1).setValue(0); // Reset saldo anggota ke 0
        } else {
          // Pastikan saldo Kas Klub juga direset ke 0 jika ini adalah reset data transaksi
          anggotaSheet.getRange(i + 1, SALDO_COL_ANGGOTA + 1).setValue(0);
        }
      }

      message = `Data transaksi dari ${startDate.toLocaleDateString()} hingga ${endDate.toLocaleDateString()} berhasil direset. Saldo anggota telah direset ke 0. Harap sesuaikan saldo secara manual jika diperlukan.`;
    } else {
      throw new Error("Tipe reset tidak valid.");
    }

    // Setelah reset apapun, mengisi ulang cache AppData
    getDashboardSummary();
    getMembers();
    getExpenses();
    getCurrentTariff();

    return { success: true, message: message };

  } catch (error) {
    Logger.log('Error mereset data: ' + error.message);
    throw new Error('Gagal mereset data: ' + error.message);
  }
}
