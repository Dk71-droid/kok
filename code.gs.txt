const SPREADSHEET_ID = '1OTo8qLrfZfK0u7GseyA9BK0kKeAJdcEYnp8heI-xT-8';
const CASH_FUND_MEMBER_ID = 'kas_klub'; // ID khusus untuk saldo kas klub
const APP_DATA_SHEET_NAME = 'AppData'; // Nama sheet untuk menyimpan data cache/formulasi

// Mapping sel untuk data cache di sheet AppData
const APP_DATA_CELLS = {
  DASHBOARD: 'A1',
  MEMBERS_AND_IURAN: 'A2', // Digunakan untuk tab Anggota dan data dropdown Iuran
  EXPENSES: 'A3',
  SETTINGS: 'A4' // Untuk tarif
};

// ===== HELPER FUNCTIONS FOR APP DATA CACHE HANDLING =====

/**
 * Reads and parses JSON data from a specific cell in the AppData sheet.
 * Uses LockService to prevent concurrent modifications.
 * @param {string} cellAddress The A1 notation of the cell (e.g., 'A1').
 * @returns {object|null} The parsed JSON object, or null if cell is empty/invalid.
 */
function readAppDataCache(cellAddress) {
  const lock = LockService.getScriptLock();
  lock.waitLock(30000); // Tunggu hingga 30 detik untuk mendapatkan kunci

  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName(APP_DATA_SHEET_NAME);
    if (!sheet) {
      Logger.log(`Sheet '${APP_DATA_SHEET_NAME}' tidak ditemukan saat membaca cache.`);
      return null;
    }

    const jsonString = sheet.getRange(cellAddress).getValue();
    if (!jsonString) {
      return null;
    }
    return JSON.parse(jsonString);
  } catch (e) {
    Logger.log(`Error reading AppData cache from ${cellAddress}: ${e.message}`);
    return null;
  } finally {
    lock.releaseLock();
  }
}

/**
 * Saves a JavaScript object as a JSON string to a specific cell in the AppData sheet.
 * Uses LockService to prevent concurrent modifications.
 * @param {string} cellAddress The A1 notation of the cell (e.g., 'A1').
 * @param {object} dataObject The object to save.
 */
function writeAppDataCache(cellAddress, dataObject) {
  const lock = LockService.getScriptLock();
  lock.waitLock(30000); // Tunggu hingga 30 detik untuk mendapatkan kunci

  try {
    const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
    const sheet = ss.getSheetByName(APP_DATA_SHEET_NAME);
    if (!sheet) {
      Logger.log(`Sheet '${APP_DATA_SHEET_NAME}' tidak ditemukan saat menulis cache.`);
      return;
    }
    sheet.getRange(cellAddress).setValue(JSON.stringify(dataObject));
  } catch (e) {
    Logger.log(`Error saving AppData cache to ${cellAddress}: ${e.message}`);
  } finally {
    lock.releaseLock();
  }
}

// ===== HANDLER GET =====
function doGet(e) {
  const action = e.parameter.action;
  let result;
  try {
    switch (action) {
      case 'getMembers': result = getMembers(); break;
      case 'getDashboardSummary': result = getDashboardSummary(); break;
      case 'getExpenses': result = getExpenses(); break;
      case 'getCurrentTariff': result = getCurrentTariff(); break;
      default:
        throw new Error('Aksi tidak dikenal: ' + action);
    }
    return ContentService.createTextOutput(JSON.stringify(result)).setMimeType(ContentService.MimeType.JSON);
  } catch (error) {
    Logger.log(`Error in doGet for action ${action}: ${error.message}`);
    return ContentService.createTextOutput(JSON.stringify({ error: error.message }))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

// ===== HANDLER POST =====
function doPost(e) {
  const action = e.parameter.action;
  const data = JSON.parse(e.parameter.data || '{}');
  let result;
  try {
    switch (action) {
      case 'addMember': result = addMember(data); break;
      case 'updateMember': result = updateMember(data); break;
      case 'deleteMember': result = deleteMember(data); break;
      case 'recordPayment': result = recordPayment(data); break;
      case 'depositBalance': result = depositBalance(data); break;
      case 'setTariff': result = setTariff(data); break;
      case 'recordExpense': result = recordExpense(data); break;
      case 'resetData': result = resetData(data); break; // Aksi baru untuk reset
      case 'recordBatchPayments': result = recordBatchPayments(data); break; // Aksi baru untuk pembayaran batch
      default:
        throw new Error('Aksi tidak dikenal (POST): ' + action);
    }
    return ContentService.createTextOutput(JSON.stringify(result)).setMimeType(ContentService.MimeType.JSON);
  } catch (error) {
    Logger.log(`Error in doPost for action ${action}: ${error.message}`);
    return ContentService.createTextOutput(JSON.stringify({ error: error.message }))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

// ===== GET MEMBERS (Membaca dari sheet 'Anggota', memperbarui cache AppData!A2) =====
function getMembers() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName('Anggota');
  if (!sheet) throw new Error("Sheet 'Anggota' tidak ditemukan.");

  const data = sheet.getDataRange().getValues();
  const members = [];

  for (let i = 1; i < data.length; i++) {
    members.push({
      id: data[i][0],
      name: data[i][1],
      balance: parseFloat(data[i][2]) || 0 // Pastikan saldo adalah angka
    });
  }

  const tariff = getTariffOnly(); // Mengambil tarif terkini dari sheet 'Tarif'
  const membersForCache = members.filter(m => m.id !== CASH_FUND_MEMBER_ID); // Memfilter Kas Klub untuk cache anggota
  
  const result = { members: membersForCache, currentTariff: tariff };
  writeAppDataCache(APP_DATA_CELLS.MEMBERS_AND_IURAN, result); // Memperbarui cache
  
  return result; // Mengembalikan objek langsung, doGet akan meng-JSON.stringify
}

// ===== GET DASHBOARD SUMMARY (Membaca dari sheet 'Anggota' & 'Iuran', memperbarui cache AppData!A1) =====
function getDashboardSummary() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const anggotaSheet = ss.getSheetByName('Anggota');
  if (!anggotaSheet) throw new Error("Sheet 'Anggota' tidak ditemukan.");

  const membersData = anggotaSheet.getDataRange().getValues();
  const members = [];
  for (let i = 1; i < membersData.length; i++) {
    const member = {
      id: membersData[i][0],
      name: membersData[i][1],
      balance: parseFloat(membersData[i][2]) || 0
    };
    members.push(member);
  }

  const unpaidDebts = []; // Ini akan berisi detail utang per anggota (berdasarkan saldo negatif)
  let totalUnpaidAmount = 0;
  let totalCashBalance = 0;

  // Mendapatkan saldo Kas Klub
  const kasKlubMember = members.find(m => m.id === CASH_FUND_MEMBER_ID);
  if (kasKlubMember) {
    totalCashBalance = kasKlubMember.balance;
  }

  // Menghitung utang belum dibayar dari saldo anggota
  members.forEach(member => {
    if (member.id !== CASH_FUND_MEMBER_ID && member.balance < 0) {
      unpaidDebts.push({
        memberId: member.id,
        name: member.name,
        amount: Math.abs(member.balance) // Utang adalah nilai absolut dari saldo negatif
      });
      totalUnpaidAmount += Math.abs(member.balance);
    }
  });

  const currentTariff = getTariffOnly();

  const dashboardSummary = {
    unpaidDebts: unpaidDebts,  // Data utang yang sudah diagregasi dari saldo anggota
    totalUnpaidAmount: totalUnpaidAmount,  // Total akumulasi utang (dari saldo negatif)
    totalCashBalance: totalCashBalance,   // Total saldo kas klub
    memberBalances: members, // Saldo semua anggota (untuk tabel)
    currentTariff: currentTariff
  };

  writeAppDataCache(APP_DATA_CELLS.DASHBOARD, dashboardSummary); // Memperbarui cache

  return dashboardSummary; // Mengembalikan objek langsung
}

/**
 * Fungsi internal untuk mencatat satu pembayaran ke sheet Iuran dan memperbarui saldo anggota.
 * Tidak melakukan cache update atau LockService, itu ditangani oleh pemanggil.
 * @param {object} payload - Payment details.
 */
function recordPaymentInternal(payload) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheetIuran = ss.getSheetByName('Iuran');
  const sheetAnggota = ss.getSheetByName('Anggota');

  if (!sheetIuran) throw new Error("Sheet 'Iuran' tidak ditemukan.");
  if (!sheetAnggota) throw new Error("Sheet 'Anggota' tidak ditemukan.");

  const anggotaData = sheetAnggota.getDataRange().getValues();
  const anggotaHeaders = anggotaData.length > 0 ? anggotaData[0] : [];
  const ID_ANGGOTA_COL_ANGGOTA = anggotaHeaders.indexOf('ID');
  const SALDO_COL_ANGGOTA = anggotaHeaders.indexOf('Saldo');
  const NAMA_COL_ANGGOTA = anggotaHeaders.indexOf('Nama'); // Perlu nama untuk sheet Iuran

  if (ID_ANGGOTA_COL_ANGGOTA === -1 || SALDO_COL_ANGGOTA === -1 || NAMA_COL_ANGGOTA === -1) {
    throw new Error("Kolom 'ID', 'Nama', atau 'Saldo' tidak ditemukan di sheet 'Anggota'.");
  }

  let memberRowIndex = -1;
  let memberName = '';
  for (let i = 1; i < anggotaData.length; i++) {
    if (anggotaData[i][ID_ANGGOTA_COL_ANGGOTA] === payload.memberId) {
      memberRowIndex = i + 1; // Baris berbasis 1
      memberName = anggotaData[i][NAMA_COL_ANGGOTA];
      break;
    }
  }

  if (memberRowIndex === -1) {
    throw new Error(`Anggota dengan ID ${payload.memberId} tidak ditemukan.`);
  }

  const nominalIuran = payload.jumlahMain * payload.tariff;
  const currentMemberBalance = parseFloat(sheetAnggota.getRange(memberRowIndex, SALDO_COL_ANGGOTA + 1).getValue()) || 0;
  const timestamp = new Date();

  // Memperbarui saldo Anggota
  // Jika statusBayar adalah 'sudah_bayar', saldo anggota bertambah (utang berkurang/saldo positif bertambah)
  // Jika statusBayar adalah 'belum_bayar', saldo anggota berkurang (utang bertambah)
  const newMemberBalance = payload.statusBayar === "sudah_bayar"
    ? currentMemberBalance + nominalIuran
    : currentMemberBalance - nominalIuran;
  sheetAnggota.getRange(memberRowIndex, SALDO_COL_ANGGOTA + 1).setValue(newMemberBalance);

  // HANYA tambahkan ke Kas Klub jika paymentMethod adalah 'cash'
  if (payload.paymentMethod === 'cash') {
    const kasKlubRowIndex = anggotaData.findIndex(row => row[ID_ANGGOTA_COL_ANGGOTA] === CASH_FUND_MEMBER_ID) + 1;
    if (kasKlubRowIndex > 0) {
      const currentKasKlubBalance = parseFloat(sheetAnggota.getRange(kasKlubRowIndex, SALDO_COL_ANGGOTA + 1).getValue()) || 0;
      sheetAnggota.getRange(kasKlubRowIndex, SALDO_COL_ANGGOTA + 1).setValue(currentKasKlubBalance + nominalIuran);
    } else {
      Logger.log(`Warning: Anggota dengan ID ${CASH_FUND_MEMBER_ID} tidak ditemukan. Dana kas tidak diperbarui untuk pembayaran 'cash'.`);
    }
  }

  // Memperbarui sheet Iuran
  sheetIuran.appendRow([
    payload.date, // Tanggal iuran
    memberName, // Nama anggota
    payload.jumlahMain, // Jumlah main
    nominalIuran, // Nominal
    payload.statusBayar === "sudah_bayar" ? "Lunas" : "Belum Lunas", // Status Iuran
    payload.paymentMethod, // Metode Pembayaran
    timestamp // Timestamp
  ]);
}


// ===== RECORD PAYMENT (Wrapper publik untuk satu pembayaran) =====
function recordPayment(payload) {
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);
  try {
    recordPaymentInternal(payload); // Panggil fungsi internal
    getMembers(); // Refresh members data first
    const updatedDashboardSummary = getDashboardSummary(); // Then refresh dashboard summary
    return { success: true, message: "Iuran berhasil dicatat.", updatedDashboard: updatedDashboardSummary };
  } finally {
    lock.releaseLock();
  }
}

/**
 * Mencatat beberapa pembayaran iuran secara bersamaan (batch).
 * @param {object} data - Objek yang berisi array pembayaran.
 * @param {Array<object>} data.payments - Array objek pembayaran, setiap objek berisi:
 * {string} memberId - ID anggota.
 * {number} jumlahMain - Jumlah main.
 * {string} statusBayar - "sudah_bayar" atau "belum_bayar".
 * {number} tariff - Tarif per main untuk pembayaran ini.
 * {string} date - Tanggal pembayaran (YYYY-MM-DD).
 * {string} memberName - Nama anggota (untuk logging/pesan).
 */
function recordBatchPayments(data) {
  const lock = LockService.getScriptLock();
  lock.waitLock(30000);

  let successCount = 0;
  let errorMessages = [];

  try {
    if (!data.payments || !Array.isArray(data.payments)) {
      throw new Error("Payload pembayaran batch tidak valid.");
    }

    data.payments.forEach(payment => {
      try {
        // Sebelum memanggil recordPaymentInternal, tentukan paymentMethod
        // berdasarkan saldo anggota saat ini. Ini penting karena saldo bisa berubah
        // selama pemrosesan batch jika ada pembayaran lain yang mempengaruhi saldo.
        const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
        const anggotaSheet = ss.getSheetByName('Anggota');
        const anggotaData = anggotaSheet.getDataRange().getValues();
        const anggotaHeaders = anggotaData.length > 0 ? anggotaData[0] : [];
        const ID_COL_ANGGOTA = anggotaHeaders.indexOf('ID');
        const SALDO_COL_ANGGOTA = anggotaHeaders.indexOf('Saldo');

        let currentMemberBalance = 0;
        for (let i = 1; i < anggotaData.length; i++) {
          if (anggotaData[i][ID_COL_ANGGOTA] === payment.memberId) {
            currentMemberBalance = parseFloat(anggotaData[i][SALDO_COL_ANGGOTA]) || 0;
            break;
          }
        }

        const nominal = payment.jumlahMain * payment.tariff;
        let determinedPaymentMethod = "none";

        if (payment.statusBayar === "sudah_bayar") {
          if (currentMemberBalance >= nominal) {
            determinedPaymentMethod = "balance";
          } else {
            determinedPaymentMethod = "cash";
          }
        }
        
        recordPaymentInternal({
          memberId: payment.memberId,
          jumlahMain: payment.jumlahMain,
          statusBayar: payment.statusBayar,
          tariff: payment.tariff,
          date: payment.date,
          paymentMethod: determinedPaymentMethod // Gunakan metode pembayaran yang ditentukan
        });
        successCount++;
      } catch (e) {
        errorMessages.push(`Gagal memproses pembayaran untuk ${payment.memberName || payment.memberId}: ${e.message}`);
        Logger.log(`Error processing batch payment for ${payment.memberName || payment.memberId}: ${e.message}`);
      }
    });

    // Setelah semua pembayaran diproses, refresh AppData cache sekali
    getMembers();
    getDashboardSummary();
    getExpenses();
    getCurrentTariff();

    return { 
      success: true, 
      message: `${successCount} pembayaran berhasil dicatat.`,
      errors: errorMessages
    };

  } catch (outerError) {
    Logger.log(`Error in recordBatchPayments: ${outerError.message}`);
    return { success: false, message: `Gagal memproses pembayaran batch: ${outerError.message}`, errors: errorMessages };
  } finally {
    lock.releaseLock();
  }
}


// ===== GET EXPENSES (Membaca dari sheet 'Pengeluaran', memperbarui cache AppData!A3) =====
function getExpenses() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName('Pengeluaran');
  if (!sheet) throw new Error("Sheet 'Pengeluaran' tidak ditemukan.");

  const data = sheet.getDataRange().getValues();
  const expenses = data.slice(1).map(r => ({ description: r[0], amount: parseFloat(r[1]) || 0, date: r[2] }));

  const result = { expenses };
  writeAppDataCache(APP_DATA_CELLS.EXPENSES, result); // Memperbarui cache

  return result; // Mengembalikan objek langsung
}

// ===== RECORD EXPENSE (Memperbarui sheet Pengeluaran & Anggota) =====
function recordExpense(data) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const expenseSheet = ss.getSheetByName('Pengeluaran');
  const memberSheet = ss.getSheetByName('Anggota');

  if (!expenseSheet) throw new Error("Sheet 'Pengeluaran' tidak ditemukan.");
  if (!memberSheet) throw new Error("Sheet 'Anggota' tidak ditemukan.");

  // 1. Menambahkan pengeluaran ke sheet 'Pengeluaran'
  expenseSheet.appendRow([data.description, data.amount, data.date]);

  // 2. Mengurangi jumlah pengeluaran dari saldo anggota 'Kas Klub'
  const memberData = memberSheet.getDataRange().getValues();
  const memberHeaders = memberData.length > 0 ? memberData[0] : [];
  const ID_COL_MEMBER = memberHeaders.indexOf('ID');
  const SALDO_COL_MEMBER = memberHeaders.indexOf('Saldo');

  let kasKlubRowIndex = -1;

  // Mencari baris anggota 'Kas Klub'
  for (let i = 1; i < memberData.length; i++) {
    if (memberData[i][ID_COL_MEMBER] === CASH_FUND_MEMBER_ID) {
      kasKlubRowIndex = i + 1; // +1 karena baris sheet berbasis 1
      break;
    }
  }

  if (kasKlubRowIndex !== -1) {
    const currentKasKlubBalance = parseFloat(memberSheet.getRange(kasKlubRowIndex, SALDO_COL_MEMBER + 1).getValue()) || 0;
    const newKasKlubBalance = currentKasKlubBalance - parseFloat(data.amount);
    memberSheet.getRange(kasKlubRowIndex, SALDO_COL_MEMBER + 1).setValue(newKasKlubBalance);
  } else {
    Logger.log(`Warning: Anggota dengan ID ${CASH_FUND_MEMBER_ID} tidak ditemukan. Pengeluaran tidak dikurangi dari saldo kas.`);
  }

  return { success: true, message: 'Pengeluaran dicatat dan saldo kas diperbarui.' };
}


// ===== DEPOSIT (Memperbarui sheet Anggota) =====
/**
 * Mencatat setoran saldo oleh anggota.
 * Setoran ini diasumsikan sebagai uang tunai baru yang masuk ke sistem.
 * Saldo anggota yang menyetor akan bertambah, dan saldo Kas Klub juga akan bertambah.
 * @param {object} data Objek yang berisi memberId dan amount.
 */
function depositBalance(data) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheetAnggota = ss.getSheetByName('Anggota');
  const sheetIuran = ss.getSheetByName('Iuran'); // Diperlukan untuk memperbarui status iuran

  if (!sheetAnggota) throw new Error("Sheet 'Anggota' tidak ditemukan.");
  if (!sheetIuran) throw new Error("Sheet 'Iuran' tidak ditemukan.");

  const anggotaData = sheetAnggota.getDataRange().getValues();
  const anggotaHeaders = anggotaData.length > 0 ? anggotaData[0] : [];
  const ID_ANGGOTA_COL_ANGGOTA = anggotaHeaders.indexOf('ID');
  const SALDO_COL_ANGGOTA = anggotaHeaders.indexOf('Saldo');

  let memberRowIndex = -1;
  for (let i = 1; i < anggotaData.length; i++) {
    if (anggotaData[i][ID_ANGGOTA_COL_ANGGOTA] === data.memberId) {
      memberRowIndex = i + 1;
      break;
    }
  }

  if (memberRowIndex === -1) {
    throw new Error("Anggota tidak ditemukan.");
  }

  // Memperbarui saldo anggota
  const currentMemberBalance = parseFloat(sheetAnggota.getRange(memberRowIndex, SALDO_COL_ANGGOTA + 1).getValue()) || 0;
  sheetAnggota.getRange(memberRowIndex, SALDO_COL_ANGGOTA + 1).setValue(currentMemberBalance + parseFloat(data.amount));

  // LOGIKA: Juga memperbarui saldo Kas Klub jika anggota biasa melakukan setoran
  // Ini karena setoran saldo diasumsikan sebagai uang tunai fisik yang masuk ke kas klub.
  if (data.memberId !== CASH_FUND_MEMBER_ID) {
    const kasKlubRowIndex = anggotaData.findIndex(row => row[ID_ANGGOTA_COL_ANGGOTA] === CASH_FUND_MEMBER_ID) + 1;
    if (kasKlubRowIndex > 0) {
      const currentKasKlubBalance = parseFloat(sheetAnggota.getRange(kasKlubRowIndex, SALDO_COL_ANGGOTA + 1).getValue()) || 0;
      sheetAnggota.getRange(kasKlubRowIndex, SALDO_COL_ANGGOTA + 1).setValue(currentKasKlubBalance + parseFloat(data.amount));
    } else {
      Logger.log(`Warning: Anggota dengan ID ${CASH_FUND_MEMBER_ID} tidak ditemukan. Saldo kas klub tidak diperbarui untuk setoran anggota.`);
    }
  }

  // Logika untuk memperbarui status Iuran berdasarkan saldo baru (hanya untuk anggota biasa)
  if (data.memberId !== CASH_FUND_MEMBER_ID) {
    let remainingPaymentToApply = parseFloat(data.amount);

    const iuranData = sheetIuran.getDataRange().getValues();
    const iuranHeaders = iuranData.length > 0 ? iuranData[0] : [];
    const ID_ANGGOTA_COL_IURAN = iuranHeaders.indexOf('ID_Anggota');
    const STATUS_BAYAR_COL_IURAN = iuranHeaders.indexOf('Status_Bayar');
    const JUMLAH_MAIN_COL_IURAN = iuranHeaders.indexOf('Jumlah_Main');
    const TARIF_SAAT_INPUT_COL_IURAN = iuranHeaders.indexOf('Tarif_Saat_Input');
    const TANGGAL_COL_IURAN = iuranHeaders.indexOf('Tanggal');

    // Memfilter entri 'Belum Lunas' untuk anggota ini, diurutkan berdasarkan tanggal (terlama dulu)
    const unpaidIuranRows = [];
    for(let i = 1; i < iuranData.length; i++) {
      if (iuranData[i][ID_ANGGOTA_COL_IURAN] === data.memberId && iuranData[i][STATUS_BAYAR_COL_IURAN] === 'belum_bayar') {
        unpaidIuranRows.push({
          rowIndex: i + 1, // Indeks baris berbasis 1 di sheet
          data: iuranData[i]
        });
      }
    }
    // Mengurutkan berdasarkan tanggal
    unpaidIuranRows.sort((a, b) => new Date(a.data[TANGGAL_COL_IURAN]) - new Date(b.data[TANGGAL_COL_IURAN]));


    for (const entry of unpaidIuranRows) {
      if (remainingPaymentToApply <= 0) break;

      const nominal = (parseFloat(entry.data[JUMLAH_MAIN_COL_IURAN]) || 0) * (parseFloat(entry.data[TARIF_SAAT_INPUT_COL_IURAN]) || 0);
      const debtForThisEntry = nominal;

      // Jika jumlah setoran mencukupi untuk melunasi iuran ini
      if (remainingPaymentToApply >= debtForThisEntry) {
        sheetIuran.getRange(entry.rowIndex, STATUS_BAYAR_COL_IURAN + 1).setValue('sudah_bayar'); // +1 untuk indeks kolom berbasis 1
        remainingPaymentToApply -= debtForThisEntry;
      } else {
        // Jika tidak cukup, iuran tetap belum lunas, tapi sisa setoran habis
        remainingPaymentToApply = 0;
      }
    }
  }

  return { success: true, message: "Saldo ditambah dan utang diperbarui." };
}

// ===== MEMBER MANAGEMENT (Memperbarui sheet Anggota) =====
function addMember(data) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName('Anggota');
  if (!sheet) throw new Error("Sheet 'Anggota' tidak ditemukan.");

  const newId = Utilities.getUuid();
  sheet.appendRow([newId, data.name, 0]);

  return { success: true, message: "Anggota ditambahkan.", id: newId };
}

function updateMember(data) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName('Anggota');
  if (!sheet) throw new Error("Sheet 'Anggota' tidak ditemukan.");

  const rows = sheet.getDataRange().getValues(); // Mendapatkan semua data termasuk header

  // Mencari baris header untuk mendapatkan indeks kolom
  const headers = rows[0];
  const ID_COL = headers.indexOf('ID');
  const NAMA_COL = headers.indexOf('Nama');

  if (ID_COL === -1 || NAMA_COL === -1) {
    throw new Error("Kolom 'ID' atau 'Nama' tidak ditemukan di sheet 'Anggota'.");
  }

  for (let i = 1; i < rows.length; i++) { // Mulai dari 1 untuk melewati header
    if (rows[i][ID_COL] === data.id) {
      sheet.getRange(i + 1, NAMA_COL + 1).setValue(data.name); // +1 untuk indeks berbasis 1
      return { success: true, message: "Anggota diperbarui." };
    }
  }
  throw new Error("Anggota tidak ditemukan.");
}

function deleteMember(data) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheetAnggota = ss.getSheetByName('Anggota');
  const sheetIuran = ss.getSheetByName('Iuran');

  if (!sheetAnggota) throw new Error("Sheet 'Anggota' tidak ditemukan.");
  if (!sheetIuran) throw new Error("Sheet 'Iuran' tidak ditemukan.");

  const anggotaRows = sheetAnggota.getDataRange().getValues();
  const anggotaHeaders = anggotaRows.length > 0 ? anggotaRows[0] : [];
  const ID_COL_ANGGOTA = anggotaHeaders.indexOf('ID');
  let memberRowToDelete = -1;
  for (let i = 1; i < anggotaRows.length; i++) {
    if (anggotaRows[i][ID_COL_ANGGOTA] === data.id) {
      memberRowToDelete = i + 1;
      break;
    }
  }

  if (memberRowToDelete !== -1) {
    sheetAnggota.deleteRow(memberRowToDelete);

    // Juga menghapus entri iuran terkait
    const iuranData = sheetIuran.getDataRange().getValues();
    const iuranHeaders = iuranData.length > 0 ? iuranData[0] : [];
    const ID_ANGGOTA_COL_IURAN = iuranHeaders.indexOf('ID_Anggota');
    const rowsToDeleteInIuran = [];
    for (let i = 1; i < iuranData.length; i++) {
      if (iuranData[i][ID_ANGGOTA_COL_IURAN] === data.id) {
        rowsToDeleteInIuran.push(i + 1);
      }
    }
    // Menghapus baris dari bawah ke atas untuk menghindari masalah pergeseran indeks
    for (let i = rowsToDeleteInIuran.length - 1; i >= 0; i--) {
      sheetIuran.deleteRow(rowsToDeleteInIuran[i]);
    }

    return { success: true, message: "Anggota dan semua iurannya berhasil dihapus." };
  }
  throw new Error("Anggota tidak ditemukan.");
}

// ===== TARIFF (Memperbarui sheet Tarif) =====
function setTariff(data) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheetTarif = ss.getSheetByName('Tarif');
  if (!sheetTarif) throw new Error("Sheet 'Tarif' tidak ditemukan.");

  // Hapus semua baris kecuali header jika ada data lama
  if (sheetTarif.getLastRow() > 1) {
    sheetTarif.deleteRows(2, sheetTarif.getLastRow() - 1);
  }
  
  sheetTarif.appendRow([parseFloat(data.tariff) || 0, data.date]);

  return { success: true, message: "Tarif disimpan." };
}

function getTariffOnly() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName('Tarif');
  if (!sheet) {
    Logger.log("Sheet 'Tarif' tidak ditemukan. Mengembalikan tarif 0.");
    return 0; // Mengembalikan 0 jika sheet tidak ditemukan
  }
  
  const lastRow = sheet.getLastRow();
  
  // Pastikan ada setidaknya satu baris data selain header
  if (lastRow <= 1) {
    Logger.log("[getTariffOnly] Sheet 'Tarif' kosong atau hanya berisi header. Mengembalikan 0.");
    return 0;
  }

  const tariffHeaders = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const TARIF_MAIN_COL = tariffHeaders.indexOf('Tarif_Main');

  if (TARIF_MAIN_COL === -1) {
    Logger.log("[getTariffOnly] Kolom 'Tarif_Main' tidak ditemukan di sheet 'Tarif'. Mengembalikan 0.");
    return 0;
  }

  const tariffValue = sheet.getRange(lastRow, TARIF_MAIN_COL + 1).getValue();
  const parsedTariff = parseFloat(tariffValue);
  
  if (isNaN(parsedTariff)) {
    Logger.log(`[getTariffOnly] Peringatan: Nilai tarif tidak dapat diurai sebagai angka (${tariffValue}). Mengembalikan 0.`);
    return 0;
  }
  return parsedTariff;
}

function getCurrentTariff() {
  const tariff = getTariffOnly();
  const result = { tariff };
  writeAppDataCache(APP_DATA_CELLS.SETTINGS, result); // Memperbarui cache
  return result; // Mengembalikan objek langsung
}

// Helper untuk membersihkan sheet dan menyiapkan data awal (digunakan oleh setupSpreadsheet dan resetData)
function _clearAndSetupSheetsInternal() {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);

  const sheetsToCreate = [
    { name: 'Anggota', headers: ['ID', 'Nama', 'Saldo'] },
    { name: 'Iuran', headers: ['Tanggal', 'Nama_Anggota', 'Jumlah_Main', 'Nominal', 'Status_Iuran', 'Metode_Pembayaran', 'Timestamp'] },
    { name: 'Pengeluaran', headers: ['Keterangan', 'Nominal', 'Tanggal'] },
    { name: 'Tarif', headers: ['Tarif_Main', 'Tanggal'] }
  ];

  sheetsToCreate.forEach(sheetInfo => {
    let sheet = ss.getSheetByName(sheetInfo.name);
    if (!sheet) {
      sheet = ss.insertSheet(sheetInfo.name);
    }
    sheet.clearContents(); // Membersihkan semua data termasuk header
    sheet.getRange(1, 1, 1, sheetInfo.headers.length).setValues([sheetInfo.headers]);
    sheet.getRange(1, 1, 1, sheetInfo.headers.length).setFontWeight('bold');

    // Tambahkan nilai default untuk sheet 'Tarif' jika baru dibuat/direset
    if (sheetInfo.name === 'Tarif') {
      if (sheet.getLastRow() === 1) { // Hanya header yang ada
        sheet.appendRow([0, new Date().toISOString().split('T')[0]]); // Tambahkan tarif 0 dengan tanggal hari ini
        Logger.log("Tarif default 0 ditambahkan ke sheet 'Tarif'.");
      }
    }
  });

  const anggotaSheet = ss.getSheetByName('Anggota');
  const anggotaData = anggotaSheet.getDataRange().getValues();
  const anggotaHeaders = anggotaData.length > 0 ? anggotaData[0] : [];
  const ID_COL_ANGGOTA_SETUP = anggotaHeaders.indexOf('ID');
  
  let kasKlubExists = false;
  for (let i = 1; i < anggotaData.length; i++) {
    if (anggotaData[i][ID_COL_ANGGOTA_SETUP] === CASH_FUND_MEMBER_ID) {
      kasKlubExists = true;
      break;
    }
  }

  if (!kasKlubExists) {
    anggotaSheet.appendRow([CASH_FUND_MEMBER_ID, 'Kas Klub', 0]);
  } else {
    // Jika Kas Klub ada, pastikan saldonya 0 jika kita melakukan reset penuh
    const kasKlubRowIndex = anggotaData.findIndex(row => row[ID_COL_ANGGOTA_SETUP] === CASH_FUND_MEMBER_ID) + 1;
    if (kasKlubRowIndex > 0) {
      anggotaSheet.getRange(kasKlubRowIndex, anggotaHeaders.indexOf('Saldo') + 1).setValue(0);
    }
  }

  // Membersihkan sheet AppData
  let appDataSheet = ss.getSheetByName(APP_DATA_SHEET_NAME);
  if (!appDataSheet) {
    appDataSheet = ss.insertSheet(APP_DATA_SHEET_NAME);
  }
  appDataSheet.clearContents();
  writeAppDataCache(APP_DATA_CELLS.DASHBOARD, {});
  writeAppDataCache(APP_DATA_CELLS.MEMBERS_AND_IURAN, { members: [], currentTariff: 0 });
  writeAppDataCache(APP_DATA_CELLS.EXPENSES, { expenses: [] });
  writeAppDataCache(APP_DATA_CELLS.SETTINGS, { tariff: 0 });
}

// ===== SETUP SPREADSHEET (Jalankan fungsi ini sekali untuk menginisialisasi sheet) =====
function setupSpreadsheet() {
  try {
    _clearAndSetupSheetsInternal(); // Menggunakan helper internal
    Logger.log('Penyiapan Spreadsheet selesai.');
    // Setelah menyiapkan semua sheet, memicu pengisian cache awal
    getDashboardSummary();
    getMembers();
    getExpenses();
    getCurrentTariff();
    Logger.log('Cache AppData berhasil diisi setelah penyiapan.');
    SpreadsheetApp.getUi().alert('Penyiapan Spreadsheet Selesai', 'Semua sheet utama dan sheet AppData untuk caching berhasil dibuat/diperbarui. Data cache telah diinisialisasi.', SpreadsheetApp.getUi().ButtonSet.OK);
  } catch (error) {
    Logger.log('Error selama penyiapan spreadsheet: ' + error.message);
    SpreadsheetApp.getUi().alert('Error', 'Gagal mengatur spreadsheet: ' + error.message, SpreadsheetApp.getUi().ButtonSet.OK);
  }
}

/**
 * Mereset data aplikasi berdasarkan tipe reset.
 * @param {object} data Objek yang berisi resetType, startDate, dan endDate.
 */
function resetData(data) {
  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const resetType = data.resetType;
  let message = "Data berhasil direset.";

  try {
    if (resetType === 'all') {
      _clearAndSetupSheetsInternal(); // Membersihkan semuanya dan menginisialisasi ulang
      message = "Semua data berhasil direset.";
    } else if (resetType === 'monthAgo' || resetType === 'dateRange') {
      const iuranSheet = ss.getSheetByName('Iuran');
      const pengeluaranSheet = ss.getSheetByName('Pengeluaran');
      const anggotaSheet = ss.getSheetByName('Anggota'); // Perlu untuk reset saldo anggota

      if (!iuranSheet) throw new Error("Sheet 'Iuran' tidak ditemukan.");
      if (!pengeluaranSheet) throw new Error("Sheet 'Pengeluaran' tidak ditemukan.");
      if (!anggotaSheet) throw new Error("Sheet 'Anggota' tidak ditemukan.");

      let startDate = null;
      let endDate = new Date(); // Tanggal akhir default hari ini

      if (resetType === 'monthAgo') {
        startDate = new Date();
        startDate.setMonth(startDate.getMonth() - 1);
        startDate.setDate(1); // Reset dari tanggal 1 bulan lalu
      } else if (resetType === 'dateRange') {
        if (!data.startDate || !data.endDate) {
          throw new Error("Rentang tanggal tidak valid.");
        }
        startDate = new Date(data.startDate);
        endDate = new Date(data.endDate);
      }
      endDate.setHours(23, 59, 59, 999); // Memastikan tanggal akhir mencakup sepanjang hari

      // Membersihkan baris di sheet Iuran dalam rentang
      const iuranData = iuranSheet.getDataRange().getValues();
      const iuranHeaders = iuranData.length > 0 ? iuranData[0] : [];
      const TANGGAL_COL_IURAN = iuranHeaders.indexOf('Tanggal');
      const rowsToDeleteIuran = [];

      for (let i = iuranData.length - 1; i >= 1; i--) { // Iterasi mundur, lewati header
        const rowDate = new Date(iuranData[i][TANGGAL_COL_IURAN]);
        if (rowDate >= startDate && rowDate <= endDate) {
          rowsToDeleteIuran.push(i + 1); // Menyimpan indeks baris berbasis 1
        }
      }
      rowsToDeleteIuran.forEach(rowIndex => iuranSheet.deleteRow(rowIndex));

      // Membersihkan baris di sheet Pengeluaran dalam rentang
      const pengeluaranData = pengeluaranSheet.getDataRange().getValues();
      const pengeluaranHeaders = pengeluaranData.length > 0 ? pengeluaranData[0] : [];
      const TANGGAL_COL_PENGELUARAN = pengeluaranHeaders.indexOf('Tanggal');
      const rowsToDeletePengeluaran = [];

      for (let i = pengeluaranData.length - 1; i >= 1; i--) { // Iterasi mundur, lewati header
        const rowDate = new Date(pengeluaranData[i][TANGGAL_COL_PENGELUARAN]);
        if (rowDate >= startDate && rowDate <= endDate) {
          rowsToDeletePengeluaran.push(i + 1); // Menyimpan indeks baris berbasis 1
        }
      }
      rowsToDeletePengeluaran.forEach(rowIndex => pengeluaranSheet.deleteRow(rowIndex));

      // Setelah menghapus transaksi, reset semua saldo anggota (kecuali Kas Klub) menjadi 0
      // Ini adalah pendekatan yang lebih aman untuk konsistensi data setelah reset sebagian transaksi.
      const anggotaData = anggotaSheet.getDataRange().getValues();
      const anggotaHeaders = anggotaData.length > 0 ? anggotaData[0] : [];
      const ID_COL_ANGGOTA = anggotaHeaders.indexOf('ID');
      const SALDO_COL_ANGGOTA = anggotaHeaders.indexOf('Saldo');

      for (let i = 1; i < anggotaData.length; i++) {
        const memberId = anggotaData[i][ID_COL_ANGGOTA];
        if (memberId !== CASH_FUND_MEMBER_ID) {
          anggotaSheet.getRange(i + 1, SALDO_COL_ANGGOTA + 1).setValue(0); // Reset saldo anggota ke 0
        } else {
          // Pastikan saldo Kas Klub juga direset ke 0 jika ini adalah reset data transaksi
          anggotaSheet.getRange(i + 1, SALDO_COL_ANGGOTA + 1).setValue(0);
        }
      }

      message = `Data transaksi dari ${startDate.toLocaleDateString()} hingga ${endDate.toLocaleDateString()} berhasil direset. Saldo anggota telah direset ke 0. Harap sesuaikan saldo secara manual jika diperlukan.`;
    } else {
      throw new Error("Tipe reset tidak valid.");
    }

    // Setelah reset apapun, mengisi ulang cache AppData
    getDashboardSummary();
    getMembers();
    getExpenses();
    getCurrentTariff();

    return { success: true, message: message };

  } catch (error) {
    Logger.log('Error mereset data: ' + error.message);
    throw new Error('Gagal mereset data: ' + error.message);
  }
}
